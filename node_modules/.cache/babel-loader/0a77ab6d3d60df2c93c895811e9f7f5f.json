{"ast":null,"code":"import { useId as useId$1, useState, useEffect } from 'react';\nimport { useIsomorphicLayoutEffect } from '@reach/utils/use-isomorphic-layout-effect';\n/*\r\n * Welcome to @reach/auto-id!\r\n\r\n * Let's see if we can make sense of why this hook exists and its\r\n * implementation.\r\n *\r\n * Some background:\r\n *   1. Accessibility APIs rely heavily on element IDs\r\n *   2. Requiring developers to put IDs on every element in Reach UI is both\r\n *      cumbersome and error-prone\r\n *   3. With a component model, we can generate IDs for them!\r\n *\r\n * Solution 1: Generate random IDs.\r\n *\r\n * This works great as long as you don't server render your app. When React (in\r\n * the client) tries to reuse the markup from the server, the IDs won't match\r\n * and React will then recreate the entire DOM tree.\r\n *\r\n * Solution 2: Increment an integer\r\n *\r\n * This sounds great. Since we're rendering the exact same tree on the server\r\n * and client, we can increment a counter and get a deterministic result between\r\n * client and server. Also, JS integers can go up to nine-quadrillion. I'm\r\n * pretty sure the tab will be closed before an app never needs\r\n * 10 quadrillion IDs!\r\n *\r\n * Problem solved, right?\r\n *\r\n * Ah, but there's a catch! React's concurrent rendering makes this approach\r\n * non-deterministic. While the client and server will end up with the same\r\n * elements in the end, depending on suspense boundaries (and possibly some user\r\n * input during the initial render) the incrementing integers won't always match\r\n * up.\r\n *\r\n * Solution 3: Don't use IDs at all on the server; patch after first render.\r\n *\r\n * What we've done here is solution 2 with some tricks. With this approach, the\r\n * ID returned is an empty string on the first render. This way the server and\r\n * client have the same markup no matter how wild the concurrent rendering may\r\n * have gotten.\r\n *\r\n * After the render, we patch up the components with an incremented ID. This\r\n * causes a double render on any components with `useId`. Shouldn't be a problem\r\n * since the components using this hook should be small, and we're only updating\r\n * the ID attribute on the DOM, nothing big is happening.\r\n *\r\n * It doesn't have to be an incremented number, though--we could do generate\r\n * random strings instead, but incrementing a number is probably the cheapest\r\n * thing we can do.\r\n *\r\n * Additionally, we only do this patchup on the very first client render ever.\r\n * Any calls to `useId` that happen dynamically in the client will be\r\n * populated immediately with a value. So, we only get the double render after\r\n * server hydration and never again, SO BACK OFF ALRIGHT?\r\n */\n\nvar serverHandoffComplete = false;\nvar id = 0;\n\nfunction genId() {\n  return ++id;\n}\n/* eslint-disable react-hooks/rules-of-hooks */\n\n/**\r\n * useId\r\n *\r\n * Autogenerate IDs to facilitate WAI-ARIA and server rendering.\r\n *\r\n * Note: The returned ID will initially be `null` and will update after a\r\n * component mounts. Users may need to supply their own ID if they need\r\n * consistent values for SSR.\r\n *\r\n * @see Docs https://reach.tech/auto-id\r\n */\n\n\nfunction useId(providedId) {\n  var _ref; // TODO: Remove error flag when updating internal deps to React 18. None of\n  // our tricks will play well with concurrent rendering anyway.\n  // @ts-expect-error\n\n\n  if (typeof useId$1 === \"function\") {\n    // @ts-expect-error\n    var _id = useId$1(providedId);\n\n    return providedId != null ? providedId : _id;\n  } // If this instance isn't part of the initial render, we don't have to do the\n  // double render/patch-up dance. We can just generate the ID and return it.\n\n\n  var initialId = providedId != null ? providedId : serverHandoffComplete ? genId() : null;\n\n  var _React$useState = useState(initialId),\n      id = _React$useState[0],\n      setId = _React$useState[1];\n\n  useIsomorphicLayoutEffect(function () {\n    if (id === null) {\n      // Patch the ID after render. We do this in `useLayoutEffect` to avoid any\n      // rendering flicker, though it'll make the first render slower (unlikely\n      // to matter, but you're welcome to measure your app and let us know if\n      // it's a problem).\n      setId(genId());\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  useEffect(function () {\n    if (serverHandoffComplete === false) {\n      // Flag all future uses of `useId` to skip the update dance. This is in\n      // `useEffect` because it goes after `useLayoutEffect`, ensuring we don't\n      // accidentally bail out of the patch-up dance prematurely.\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return (_ref = providedId != null ? providedId : id) != null ? _ref : undefined;\n}\n\nexport { useId };","map":{"version":3,"names":["useId","useId$1","useState","useEffect","useIsomorphicLayoutEffect","serverHandoffComplete","id","genId","providedId","_ref","_id","initialId","_React$useState","setId","undefined"],"sources":["C:/Users/jeanl/Documents/bus-stops-app/maps-app/node_modules/@reach/combobox/node_modules/@reach/auto-id/dist/reach-auto-id.esm.js"],"sourcesContent":["import { useId as useId$1, useState, useEffect } from 'react';\r\nimport { useIsomorphicLayoutEffect } from '@reach/utils/use-isomorphic-layout-effect';\r\n\r\n/*\r\n * Welcome to @reach/auto-id!\r\n\r\n * Let's see if we can make sense of why this hook exists and its\r\n * implementation.\r\n *\r\n * Some background:\r\n *   1. Accessibility APIs rely heavily on element IDs\r\n *   2. Requiring developers to put IDs on every element in Reach UI is both\r\n *      cumbersome and error-prone\r\n *   3. With a component model, we can generate IDs for them!\r\n *\r\n * Solution 1: Generate random IDs.\r\n *\r\n * This works great as long as you don't server render your app. When React (in\r\n * the client) tries to reuse the markup from the server, the IDs won't match\r\n * and React will then recreate the entire DOM tree.\r\n *\r\n * Solution 2: Increment an integer\r\n *\r\n * This sounds great. Since we're rendering the exact same tree on the server\r\n * and client, we can increment a counter and get a deterministic result between\r\n * client and server. Also, JS integers can go up to nine-quadrillion. I'm\r\n * pretty sure the tab will be closed before an app never needs\r\n * 10 quadrillion IDs!\r\n *\r\n * Problem solved, right?\r\n *\r\n * Ah, but there's a catch! React's concurrent rendering makes this approach\r\n * non-deterministic. While the client and server will end up with the same\r\n * elements in the end, depending on suspense boundaries (and possibly some user\r\n * input during the initial render) the incrementing integers won't always match\r\n * up.\r\n *\r\n * Solution 3: Don't use IDs at all on the server; patch after first render.\r\n *\r\n * What we've done here is solution 2 with some tricks. With this approach, the\r\n * ID returned is an empty string on the first render. This way the server and\r\n * client have the same markup no matter how wild the concurrent rendering may\r\n * have gotten.\r\n *\r\n * After the render, we patch up the components with an incremented ID. This\r\n * causes a double render on any components with `useId`. Shouldn't be a problem\r\n * since the components using this hook should be small, and we're only updating\r\n * the ID attribute on the DOM, nothing big is happening.\r\n *\r\n * It doesn't have to be an incremented number, though--we could do generate\r\n * random strings instead, but incrementing a number is probably the cheapest\r\n * thing we can do.\r\n *\r\n * Additionally, we only do this patchup on the very first client render ever.\r\n * Any calls to `useId` that happen dynamically in the client will be\r\n * populated immediately with a value. So, we only get the double render after\r\n * server hydration and never again, SO BACK OFF ALRIGHT?\r\n */\r\nvar serverHandoffComplete = false;\r\nvar id = 0;\r\n\r\nfunction genId() {\r\n  return ++id;\r\n}\r\n/* eslint-disable react-hooks/rules-of-hooks */\r\n\r\n/**\r\n * useId\r\n *\r\n * Autogenerate IDs to facilitate WAI-ARIA and server rendering.\r\n *\r\n * Note: The returned ID will initially be `null` and will update after a\r\n * component mounts. Users may need to supply their own ID if they need\r\n * consistent values for SSR.\r\n *\r\n * @see Docs https://reach.tech/auto-id\r\n */\r\n\r\n\r\nfunction useId(providedId) {\r\n  var _ref;\r\n\r\n  // TODO: Remove error flag when updating internal deps to React 18. None of\r\n  // our tricks will play well with concurrent rendering anyway.\r\n  // @ts-expect-error\r\n  if (typeof useId$1 === \"function\") {\r\n    // @ts-expect-error\r\n    var _id = useId$1(providedId);\r\n\r\n    return providedId != null ? providedId : _id;\r\n  } // If this instance isn't part of the initial render, we don't have to do the\r\n  // double render/patch-up dance. We can just generate the ID and return it.\r\n\r\n\r\n  var initialId = providedId != null ? providedId : serverHandoffComplete ? genId() : null;\r\n\r\n  var _React$useState = useState(initialId),\r\n      id = _React$useState[0],\r\n      setId = _React$useState[1];\r\n\r\n  useIsomorphicLayoutEffect(function () {\r\n    if (id === null) {\r\n      // Patch the ID after render. We do this in `useLayoutEffect` to avoid any\r\n      // rendering flicker, though it'll make the first render slower (unlikely\r\n      // to matter, but you're welcome to measure your app and let us know if\r\n      // it's a problem).\r\n      setId(genId());\r\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\r\n\r\n  }, []);\r\n  useEffect(function () {\r\n    if (serverHandoffComplete === false) {\r\n      // Flag all future uses of `useId` to skip the update dance. This is in\r\n      // `useEffect` because it goes after `useLayoutEffect`, ensuring we don't\r\n      // accidentally bail out of the patch-up dance prematurely.\r\n      serverHandoffComplete = true;\r\n    }\r\n  }, []);\r\n  return (_ref = providedId != null ? providedId : id) != null ? _ref : undefined;\r\n}\r\n\r\nexport { useId };\r\n"],"mappings":"AAAA,SAASA,KAAK,IAAIC,OAAlB,EAA2BC,QAA3B,EAAqCC,SAArC,QAAsD,OAAtD;AACA,SAASC,yBAAT,QAA0C,2CAA1C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,qBAAqB,GAAG,KAA5B;AACA,IAAIC,EAAE,GAAG,CAAT;;AAEA,SAASC,KAAT,GAAiB;EACf,OAAO,EAAED,EAAT;AACD;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASN,KAAT,CAAeQ,UAAf,EAA2B;EACzB,IAAIC,IAAJ,CADyB,CAGzB;EACA;EACA;;;EACA,IAAI,OAAOR,OAAP,KAAmB,UAAvB,EAAmC;IACjC;IACA,IAAIS,GAAG,GAAGT,OAAO,CAACO,UAAD,CAAjB;;IAEA,OAAOA,UAAU,IAAI,IAAd,GAAqBA,UAArB,GAAkCE,GAAzC;EACD,CAXwB,CAWvB;EACF;;;EAGA,IAAIC,SAAS,GAAGH,UAAU,IAAI,IAAd,GAAqBA,UAArB,GAAkCH,qBAAqB,GAAGE,KAAK,EAAR,GAAa,IAApF;;EAEA,IAAIK,eAAe,GAAGV,QAAQ,CAACS,SAAD,CAA9B;EAAA,IACIL,EAAE,GAAGM,eAAe,CAAC,CAAD,CADxB;EAAA,IAEIC,KAAK,GAAGD,eAAe,CAAC,CAAD,CAF3B;;EAIAR,yBAAyB,CAAC,YAAY;IACpC,IAAIE,EAAE,KAAK,IAAX,EAAiB;MACf;MACA;MACA;MACA;MACAO,KAAK,CAACN,KAAK,EAAN,CAAL;IACD,CAPmC,CAOlC;;EAEH,CATwB,EAStB,EATsB,CAAzB;EAUAJ,SAAS,CAAC,YAAY;IACpB,IAAIE,qBAAqB,KAAK,KAA9B,EAAqC;MACnC;MACA;MACA;MACAA,qBAAqB,GAAG,IAAxB;IACD;EACF,CAPQ,EAON,EAPM,CAAT;EAQA,OAAO,CAACI,IAAI,GAAGD,UAAU,IAAI,IAAd,GAAqBA,UAArB,GAAkCF,EAA1C,KAAiD,IAAjD,GAAwDG,IAAxD,GAA+DK,SAAtE;AACD;;AAED,SAASd,KAAT"},"metadata":{},"sourceType":"module"}